import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as i,d as n}from"./app-CcO3HkfD.js";const a={},l=n(`<h2 id="onclick与id冲突" tabindex="-1"><a class="header-anchor" href="#onclick与id冲突"><span>onclick与id冲突</span></a></h2><p>HTML：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>&lt;button class=&quot;btn btn-info&quot; id=&quot;price_rule&quot; onclick=&quot;price_rule()&quot; type=&quot;button&quot;&gt;</span></span>
<span class="line"><span>定时改价</span></span>
<span class="line"><span>&lt;/button&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>JS：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>function price_rule(){</span></span>
<span class="line"><span>	console.log(1);</span></span>
<span class="line"><span>	return ;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上写法，点击button，方法没有反应。需要将id的值与onclick的值变为不相同的才可以</p><h2 id="layui介绍" tabindex="-1"><a class="header-anchor" href="#layui介绍"><span>layui介绍</span></a></h2><p>快速,灵活和务实,大道至简,良好的文档和示例,极具生产力的一个UI框架.LayUI,我的理解是,它本质 还是一个基于jQuery的UI框架,比如它的灵魂组件layer弹出层对象layero本质就是一个jQuery对象, LayUI是内置了jQuery库的.举个例子,LayUI在功能上,可以说是全覆盖了 Vue+Axios+ElementUI 这套 MVVM前端方案.jQuery 对标 Vue.jQuery的AJAX 对标 Axios.LayUI 对标 ElementUI.如果工期紧张,人 手不足,那么LayUI这套方案绝对是一个差不到哪的选择.总之就是,门槛很低,但上限并不低. 看一下LayUI的零依赖的部署方式和全模块的加载方式,就大概能知道LayUI的设计哲学了.</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>&lt;link rel=&quot;stylesheet&quot; href=&quot;/layui/css/layui.css&quot;&gt;</span></span>
<span class="line"><span>&lt;script src=&quot;/layui/layui.all.js&quot;&gt;&lt;/script&gt;</span></span>
<span class="line"><span>&lt;script&gt;</span></span>
<span class="line"><span>(function(){</span></span>
<span class="line"><span>	var layer = layui.layer;</span></span>
<span class="line"><span>	layer.msg(&#39;Hello World&#39;);</span></span>
<span class="line"><span>})();</span></span>
<span class="line"><span>&lt;/script&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>LayUI也提供了模块化加载的方法,但个人并不喜欢:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>&lt;link rel=&quot;stylesheet&quot; href=&quot;/layui/css/layui.css&quot;&gt;</span></span>
<span class="line"><span>&lt;script src=&quot;/layui/layui.js&quot;&gt;&lt;/script&gt;</span></span>
<span class="line"><span>&lt;script&gt;</span></span>
<span class="line"><span>layui.use([&#39;layer&#39;, &#39;form&#39;], function(){</span></span>
<span class="line"><span>	var layer = layui.layer;</span></span>
<span class="line"><span>	var from = layui.form;</span></span>
<span class="line"><span>	layer.msg(&#39;Hello World&#39;);</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span>&lt;/script&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作者：eechen 链接：https://www.zhihu.com/question/58435239/answer/1096615048 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="layui介绍-1" tabindex="-1"><a class="header-anchor" href="#layui介绍-1"><span>layui介绍</span></a></h2><p>我之前是做传统电信系统的，记得以前做功能的时候，一般都是一个人前端后端都做的，后来到互联网公司了， 大家开始搞前后端分离了，前端专心做前端，后端专心做后端，最开始的时候还能读懂前端的代码，后来随着 前端技术的突飞猛进，就不再能看懂了，对我这个后端程序员来说要做个界面只能老老实实用easyui， bootstrap，最近才开始用layui，发现确实很不错，学习成本低，开发成本也低，对我来说确实是个福音，给 贤心点100个赞~</p><p>作者：郭virgil 链接：https://www.zhihu.com/question/58435239/answer/173946163 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="获取iframe当前的url" tabindex="-1"><a class="header-anchor" href="#获取iframe当前的url"><span>获取IFRAME当前的URL</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>parent.document.getElementById(&quot;content_info&quot;).contentWindow.location.href</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="薛定谔的猫-现象" tabindex="-1"><a class="header-anchor" href="#薛定谔的猫-现象"><span>”薛定谔的猫“现象</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>wsAction.close()</span></span>
<span class="line"><span>this.wsStatus = wsAction.status</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(this.usersList);</span></span>
<span class="line"><span>debugger</span></span>
<span class="line"><span>// 监听器 打开链接</span></span>
<span class="line"><span>let onopen = function ( {evt} ){</span></span>
<span class="line"><span>	vthis.wsStatus = wsAction.status</span></span>
<span class="line"><span>	vthis.autoLogin()</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>this.usersList = {...}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码片段，debugger 之上的log ，在”看“之前 执行，和”看“之后执行的结果不一样。 具体就是，程序执行到 debuger 暂停，去看一眼输出的log的变量值，执行完再去看，这是一种情况 另一种就是，程序执行到 debuger 暂停，这时候不去看输出的log变量值，继续执行完程序，然后再去看 输出的值，这时候竟然是另一张情况。</p><h2 id="怎么样彻底-锁死-const-定义的常量" tabindex="-1"><a class="header-anchor" href="#怎么样彻底-锁死-const-定义的常量"><span>怎么样彻底“锁死”const 定义的常量</span></a></h2><blockquote><p>可以使用Object.freeze()方法来 冻结变量</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>const obj = {</span></span>
<span class="line"><span>  name:&quot;1024kb&quot;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>Object.freeze(obj)</span></span>
<span class="line"><span>// 此时对象obj被冻结，返回被冻结的对象</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，被冻结后的对象不仅仅是不能修改值，同时也</p><blockquote><p>不能向这个对象添加新的属性 不能修改其已有属性的值 不能删除已有属性 不能修改该对象已有属性的可枚举性、可配置性、可写性 建议判断清除情况再进行使用</p></blockquote>`,25),t=[l];function r(p,c){return i(),e("div",null,t)}const u=s(a,[["render",r],["__file","js.html.vue"]]),h=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/js.html","title":"JS代码记录","lang":"zh-CN","frontmatter":{"title":"JS代码记录","icon":"fab fa-markdown","order":2,"category":["技术记录"],"tag":["技术","随笔"],"date":"2024-05-31T00:00:00.000Z","description":"onclick与id冲突 HTML： JS： 以上写法，点击button，方法没有反应。需要将id的值与onclick的值变为不相同的才可以 layui介绍 快速,灵活和务实,大道至简,良好的文档和示例,极具生产力的一个UI框架.LayUI,我的理解是,它本质 还是一个基于jQuery的UI框架,比如它的灵魂组件layer弹出层对象layero本质就是...","head":[["meta",{"property":"og:url","content":"https://jijacky.github.io/%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/js.html"}],["meta",{"property":"og:title","content":"JS代码记录"}],["meta",{"property":"og:description","content":"onclick与id冲突 HTML： JS： 以上写法，点击button，方法没有反应。需要将id的值与onclick的值变为不相同的才可以 layui介绍 快速,灵活和务实,大道至简,良好的文档和示例,极具生产力的一个UI框架.LayUI,我的理解是,它本质 还是一个基于jQuery的UI框架,比如它的灵魂组件layer弹出层对象layero本质就是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-06T10:05:17.000Z"}],["meta",{"property":"article:author","content":"Veeooo"}],["meta",{"property":"article:tag","content":"技术"}],["meta",{"property":"article:tag","content":"随笔"}],["meta",{"property":"article:published_time","content":"2024-05-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-06T10:05:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JS代码记录\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-06T10:05:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Veeooo\\",\\"url\\":\\"https://github.com/jijacky\\"}]}"]]},"headers":[{"level":2,"title":"onclick与id冲突","slug":"onclick与id冲突","link":"#onclick与id冲突","children":[]},{"level":2,"title":"layui介绍","slug":"layui介绍","link":"#layui介绍","children":[]},{"level":2,"title":"layui介绍","slug":"layui介绍-1","link":"#layui介绍-1","children":[]},{"level":2,"title":"获取IFRAME当前的URL","slug":"获取iframe当前的url","link":"#获取iframe当前的url","children":[]},{"level":2,"title":"”薛定谔的猫“现象","slug":"薛定谔的猫-现象","link":"#薛定谔的猫-现象","children":[]},{"level":2,"title":"怎么样彻底“锁死”const 定义的常量","slug":"怎么样彻底-锁死-const-定义的常量","link":"#怎么样彻底-锁死-const-定义的常量","children":[]}],"git":{"createdTime":1717668317000,"updatedTime":1717668317000,"contributors":[{"name":"jijacky","email":"jijacky@126.com","commits":1}]},"readingTime":{"minutes":3.06,"words":917},"filePathRelative":"技术记录/js.md","localizedDate":"2024年5月31日","excerpt":"<h2>onclick与id冲突</h2>\\n<p>HTML：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>&lt;button class=\\"btn btn-info\\" id=\\"price_rule\\" onclick=\\"price_rule()\\" type=\\"button\\"&gt;</span></span>\\n<span class=\\"line\\"><span>定时改价</span></span>\\n<span class=\\"line\\"><span>&lt;/button&gt;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{u as comp,h as data};
